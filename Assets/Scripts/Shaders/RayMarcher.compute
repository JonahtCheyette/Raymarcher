#pragma kernel CSMain

static const int maxMarchingSteps = 150;
static const float maxMarchingDistance = 100;
static const float surfDistance = 0.01;

float4x4 cameraInverseProjection;
float4x4 cameraToWorld;
bool renderSpheres;
bool renderPlanes;
bool renderBoxes;
bool renderTori;
bool renderCylinders;

float3 light;

struct box {
    float3 center;
    float3 size;
    //gotta love quaternions
    float4 rotation;
    float3 color;
};

struct sphere {
    float3 center;
    float radius;
    float3 color;
};

struct torus {
    float3 center;
    //size of the big cirlce & size of the smaller circle
    float2 torusDimensions;
    //gotta love quaternions
    float4 rotation;
    float3 color;
};

struct plane {
    //distance along the axis specified, think of it as the plane's center
    float distAlongNormal;
    float3 surfaceNormal;
    float3 color;
};

struct cylinder {
    float3 center;
    float height;
    float radius;
    //gotta love quaternions
    float4 rotation;
    float3 color;
};

RWTexture2D<float4> result;
StructuredBuffer<box> boxes;
StructuredBuffer<sphere> spheres;
StructuredBuffer<torus> tori;
StructuredBuffer<plane> planes;
StructuredBuffer<cylinder> cylinders;

float3 rotatePoint(float3 p, float4 q) {
    //rotating a point by a quaternion
    //assuming quaterinions are in the forem x, y, z, w
    return cross(cross(q.xyz, p) + q.w * p, -q.xyz) + dot(q.xyz, p) * q.xyz + q.w * (cross(q.xyz, p) + q.w * p);
}

float sdSphere (float3 p, sphere s) {
    return length(p - s.center) - s.radius;
}

float sdBox (float3 p, box b) {
    float3 pos = rotatePoint(p - b.center, float4(-b.rotation.xyz, b.rotation.w));
    float3 offset = abs(pos) - b.size;
    //distance from point outside box to edge (0 if inside box)
    //max/min operation on vectpr dpes it component by component
    float unsignedDst = length(max(offset, 0));
    //-dst from point inside box to edge (0 if outside box)
    float dstInsideBox = max(max(min(offset.x, 0), min(offset.y, 0)), min(offset.z, 0));
    return unsignedDst + dstInsideBox;
}

float sdTorus (float3 p, torus t) {
    float3 pos = rotatePoint(p - t.center, float4(-t.rotation.xyz, t.rotation.w));
    float2 q = float2(length(pos.xz) - t.torusDimensions.x, pos.y);
    return length(q) - t.torusDimensions.y;
}

float sdPlane (float3 p, plane pl) {
    return dot(p, pl.surfaceNormal) - pl.distAlongNormal;
}

float sdCylinder (float3 p, cylinder c) {
    float3 pos = rotatePoint(p - c.center, float4(-c.rotation.xyz, c.rotation.w));
    float2 d = abs(float2(length(pos.xz), pos.y)) - float2(c.radius, c.height);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float3 CreateCameraRay(float2 uv) {
    // Invert the perspective projection of the view-space position
    //gets rid of the projection that the camera does.
    float3 direction = mul(cameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    //takes a direction shooting out from the camera and transforms it into a direction in world space
    direction = mul(cameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return direction;
}

float smin(float a, float b, float k) {
    float res = exp2(-k * a) + exp2(-k * b);
    return -log2(res) / k;
}

float distToScene(float3 p) {
    float distance = 3.402823466e+38F;
    uint numShapes, stride;

    if (renderBoxes) {
        boxes.GetDimensions(numShapes, stride);
        for (uint i = 0; i < numShapes; i++) {
            float boxDistance = sdBox(p, boxes[i]);

            distance = min(distance, boxDistance);
        }
    }

    if (renderSpheres) {
        spheres.GetDimensions(numShapes, stride);
        for (uint j = 0; j < numShapes; j++) {
            float sphereDistance = sdSphere(p, spheres[j]);

            distance = min(distance, sphereDistance);
        }
    }
    
    if (renderTori) {
        tori.GetDimensions(numShapes, stride);
        for (uint k = 0; k < numShapes; k++) {
            float torusDistance = sdTorus(p, tori[k]);

            distance = min(distance, torusDistance);
        }
    }

    if (renderPlanes) {
        planes.GetDimensions(numShapes, stride);
        for (uint m = 0; m < numShapes; m++) {
            float planeDistance = sdPlane(p, planes[m]);

            distance = min(distance, planeDistance);
        }
    }
    
    if (renderCylinders) {
        cylinders.GetDimensions(numShapes, stride);
        for (uint n = 0; n < numShapes; n++) {
            float cylinderDistance = sdCylinder(p, cylinders[n]);

            distance = min(distance, cylinderDistance);
        }
    }

    return distance;
}

float rayMarch(float3 startPos, float3 dir) {
    float d = 0;

    for (int i = 0; i < maxMarchingSteps; i++) {
        float3 p = startPos + d * dir;
        float dist = distToScene(p);
        d += dist;
        if (d > maxMarchingDistance || d < surfDistance) {
            break;
        }
    }

    return d;
}

float3 getNormal(float3 p) {
    float2 e = float2(0.01, 0);
    float d = distToScene(p);
    float3 n = float3(d - distToScene(p - e.xyy), d - distToScene(p - e.yxy), d - distToScene(p - e.yyx));
    return normalize(n);
}

float getLighting(float3 p) {
    float3 l;
    l = normalize(light - p);

    float3 n = getNormal(p);
    float dif = dot(n, l);
    float d = rayMarch(p + surfDistance * 2 * n, l);

    if (d < length(light - p)) {
        dif *= 0.1;
    }

    return dif;
}

[numthreads(8, 4, 1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
    // Get the dimensions of the RenderTexture
    uint width, height;
    result.GetDimensions(width, height);

    float3 cameraPos = mul(cameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    float3 rayDir = CreateCameraRay(float2((id.xy) / float2(width, height) * 2.0f - 1.0f));

    float dist = rayMarch(cameraPos, rayDir);
    float3 endPoint = cameraPos + dist * rayDir;

    float l = getLighting(endPoint);
    result[id.xy] = float4(l, l, l, 1);
    /*
    if (dist < maxMarchingDistance) {
        float lighting = getLighting(endPoint);
        result[id.xy] = float4(getNormal(endPoint), 1);
    } else {
        result[id.xy] = float4(0.2, 0.2, 0.2, 1);
    }*/
}
